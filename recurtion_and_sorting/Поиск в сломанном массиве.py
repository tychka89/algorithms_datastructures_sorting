'''
Поиск в сломанном массиве

Алла ошиблась при копировании из одной структуры данных в другую.
Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив,
но сдвинула данные исходной отсортированной последовательности.
Теперь массив не является отсортированным. Тем не менее, нужно обеспечить возможность
находить в нем элемент за O(log n). Можно предполагать, что в массиве только уникальные элементы.
От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве.

Формат ввода
Функция принимает массив натуральных чисел и искомое число k . Длина массива не превосходит 10000.
Элементы массива и число k не превосходят по значению 10000.
В примерах: В первой строке записано число n –— длина массива.
Во второй строке записано положительное число k –— искомый элемент.
Далее в строку через пробел записано n натуральных чисел – элементы массива.

Формат вывода
Функция должна вернуть индекс элемента, равного k, если такой есть в массиве (нумерация с нуля).
Если элемент не найден, функция должна вернуть −1. Изменять массив нельзя.
Для отсечения неэффективных решений ваша функция будет запускаться от 100000 до 1000000 раз.

Пример
Ввод
9
5
19 21 100 101 1 4 5 7 12

Вывод
6
'''

from typing import List

def is_target_left_side(nums: List[int], start_index: int, end_index: int, target: int, middle: int) -> bool:
    return ((nums[start_index] <= nums[middle]) and (nums[start_index] <= target < nums[middle])) \
    or ((nums[start_index] <= nums[middle]) == False) and ((nums[middle] < target <= nums[end_index]) == False)

def broken_search(nums: List[int], target: int) -> int:
    start_index: int = 0
    end_index: int = len(nums) - 1
    while start_index <= end_index:
        middle: int = (start_index + end_index) // 2
        if nums[middle] == target:
            return middle
        elif is_target_left_side(nums, start_index, end_index, target, middle):
            end_index = middle - 1
        else:
            start_index = middle + 1
    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6